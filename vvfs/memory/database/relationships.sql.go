// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: relationships.sql

package database

import (
	"context"
	"database/sql"
)

const batchCreateEntityFileRelations = `-- name: BatchCreateEntityFileRelations :exec
INSERT INTO entity_file_relations (
        entity_name,
        file_id,
        relation_type,
        confidence,
        similarity_score,
        metadata,
        created_at
    )
VALUES (?, ?, ?, ?, ?, ?, ?)
`

type BatchCreateEntityFileRelationsParams struct {
	EntityName      string  `json:"entity_name"`
	FileID          string  `json:"file_id"`
	RelationType    string  `json:"relation_type"`
	Confidence      float64 `json:"confidence"`
	SimilarityScore float64 `json:"similarity_score"`
	Metadata        string  `json:"metadata"`
	CreatedAt       int64   `json:"created_at"`
}

// Batch create multiple entity-file relationships
func (q *Queries) BatchCreateEntityFileRelations(ctx context.Context, arg BatchCreateEntityFileRelationsParams) error {
	_, err := q.exec(ctx, q.batchCreateEntityFileRelationsStmt, batchCreateEntityFileRelations,
		arg.EntityName,
		arg.FileID,
		arg.RelationType,
		arg.Confidence,
		arg.SimilarityScore,
		arg.Metadata,
		arg.CreatedAt,
	)
	return err
}

const batchUpdateRelationConfidence = `-- name: BatchUpdateRelationConfidence :exec
UPDATE entity_file_relations
SET confidence = ?,
    similarity_score = ?
WHERE id = ?
`

type BatchUpdateRelationConfidenceParams struct {
	Confidence      float64 `json:"confidence"`
	SimilarityScore float64 `json:"similarity_score"`
	ID              int64   `json:"id"`
}

// Batch update confidence scores
func (q *Queries) BatchUpdateRelationConfidence(ctx context.Context, arg BatchUpdateRelationConfidenceParams) error {
	_, err := q.exec(ctx, q.batchUpdateRelationConfidenceStmt, batchUpdateRelationConfidence, arg.Confidence, arg.SimilarityScore, arg.ID)
	return err
}

const cleanupLowConfidenceRelations = `-- name: CleanupLowConfidenceRelations :exec
DELETE FROM entity_file_relations
WHERE confidence < ?
`

// Remove relationships below confidence threshold
func (q *Queries) CleanupLowConfidenceRelations(ctx context.Context, confidence float64) error {
	_, err := q.exec(ctx, q.cleanupLowConfidenceRelationsStmt, cleanupLowConfidenceRelations, confidence)
	return err
}

const createEntityFileRelation = `-- name: CreateEntityFileRelation :one
INSERT INTO entity_file_relations (
        entity_name,
        file_id,
        relation_type,
        confidence,
        similarity_score,
        metadata,
        created_at
    )
VALUES (?, ?, ?, ?, ?, ?, ?)
RETURNING id,
    entity_name,
    file_id,
    relation_type,
    confidence,
    similarity_score,
    metadata,
    created_at
`

type CreateEntityFileRelationParams struct {
	EntityName      string  `json:"entity_name"`
	FileID          string  `json:"file_id"`
	RelationType    string  `json:"relation_type"`
	Confidence      float64 `json:"confidence"`
	SimilarityScore float64 `json:"similarity_score"`
	Metadata        string  `json:"metadata"`
	CreatedAt       int64   `json:"created_at"`
}

// Create a relationship between entity and file
func (q *Queries) CreateEntityFileRelation(ctx context.Context, arg CreateEntityFileRelationParams) (EntityFileRelation, error) {
	row := q.queryRow(ctx, q.createEntityFileRelationStmt, createEntityFileRelation,
		arg.EntityName,
		arg.FileID,
		arg.RelationType,
		arg.Confidence,
		arg.SimilarityScore,
		arg.Metadata,
		arg.CreatedAt,
	)
	var i EntityFileRelation
	err := row.Scan(
		&i.ID,
		&i.EntityName,
		&i.FileID,
		&i.RelationType,
		&i.Confidence,
		&i.SimilarityScore,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const deleteEntityFileRelation = `-- name: DeleteEntityFileRelation :exec
DELETE FROM entity_file_relations
WHERE entity_name = ?
    AND file_id = ?
    AND relation_type = ?
`

type DeleteEntityFileRelationParams struct {
	EntityName   string `json:"entity_name"`
	FileID       string `json:"file_id"`
	RelationType string `json:"relation_type"`
}

// Delete specific relationship
func (q *Queries) DeleteEntityFileRelation(ctx context.Context, arg DeleteEntityFileRelationParams) error {
	_, err := q.exec(ctx, q.deleteEntityFileRelationStmt, deleteEntityFileRelation, arg.EntityName, arg.FileID, arg.RelationType)
	return err
}

const getEntityFileNetwork = `-- name: GetEntityFileNetwork :many
WITH entity_relations AS (
    SELECT er.entity_name,
        er.file_id,
        er.relation_type,
        er.confidence,
        er.similarity_score,
        ROW_NUMBER() OVER (
            PARTITION BY er.entity_name
            ORDER BY er.confidence DESC
        ) as rn
    FROM entity_file_relations er
    WHERE er.confidence >= ?
),
file_relations AS (
    SELECT fr.file_id,
        fr.entity_name,
        fr.relation_type,
        fr.confidence,
        fr.similarity_score,
        ROW_NUMBER() OVER (
            PARTITION BY fr.file_id
            ORDER BY fr.confidence DESC
        ) as rn
    FROM entity_file_relations fr
    WHERE fr.confidence >= ?
)
SELECT 'entity_to_file' as connection_type,
    er.entity_name as source,
    f.file_path as target,
    er.relation_type,
    er.confidence,
    er.similarity_score
FROM entity_relations er
    JOIN files f ON er.file_id = f.id
WHERE er.rn <= 5 -- Top 5 relations per entity
UNION ALL
SELECT 'file_to_entity' as connection_type,
    f.file_path as source,
    fr.entity_name as target,
    fr.relation_type,
    fr.confidence,
    fr.similarity_score
FROM file_relations fr
    JOIN files f ON fr.file_id = f.id
WHERE fr.rn <= 5 -- Top 5 relations per file
ORDER BY confidence DESC
`

type GetEntityFileNetworkParams struct {
	Confidence   float64 `json:"confidence"`
	Confidence_2 float64 `json:"confidence_2"`
}

type GetEntityFileNetworkRow struct {
	ConnectionType  string  `json:"connection_type"`
	Source          string  `json:"source"`
	Target          string  `json:"target"`
	RelationType    string  `json:"relation_type"`
	Confidence      float64 `json:"confidence"`
	SimilarityScore float64 `json:"similarity_score"`
}

// Get network of relationships for analysis using CTEs
func (q *Queries) GetEntityFileNetwork(ctx context.Context, arg GetEntityFileNetworkParams) ([]GetEntityFileNetworkRow, error) {
	rows, err := q.query(ctx, q.getEntityFileNetworkStmt, getEntityFileNetwork, arg.Confidence, arg.Confidence_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEntityFileNetworkRow{}
	for rows.Next() {
		var i GetEntityFileNetworkRow
		if err := rows.Scan(
			&i.ConnectionType,
			&i.Source,
			&i.Target,
			&i.RelationType,
			&i.Confidence,
			&i.SimilarityScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEntityFileRelation = `-- name: GetEntityFileRelation :one
SELECT id,
    entity_name,
    file_id,
    relation_type,
    confidence,
    similarity_score,
    metadata,
    created_at
FROM entity_file_relations
WHERE entity_name = ?
    AND file_id = ?
    AND relation_type = ?
`

type GetEntityFileRelationParams struct {
	EntityName   string `json:"entity_name"`
	FileID       string `json:"file_id"`
	RelationType string `json:"relation_type"`
}

// Get specific entity-file relationship
func (q *Queries) GetEntityFileRelation(ctx context.Context, arg GetEntityFileRelationParams) (EntityFileRelation, error) {
	row := q.queryRow(ctx, q.getEntityFileRelationStmt, getEntityFileRelation, arg.EntityName, arg.FileID, arg.RelationType)
	var i EntityFileRelation
	err := row.Scan(
		&i.ID,
		&i.EntityName,
		&i.FileID,
		&i.RelationType,
		&i.Confidence,
		&i.SimilarityScore,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const getEntityRelations = `-- name: GetEntityRelations :many
SELECT efr.id,
    efr.entity_name,
    efr.file_id,
    efr.relation_type,
    efr.confidence,
    efr.similarity_score,
    efr.metadata,
    efr.created_at,
    f.file_path,
    f.workspace_id
FROM entity_file_relations efr
    JOIN files f ON efr.file_id = f.id
WHERE efr.entity_name = ?
ORDER BY efr.confidence DESC,
    efr.similarity_score DESC
`

type GetEntityRelationsRow struct {
	ID              int64   `json:"id"`
	EntityName      string  `json:"entity_name"`
	FileID          string  `json:"file_id"`
	RelationType    string  `json:"relation_type"`
	Confidence      float64 `json:"confidence"`
	SimilarityScore float64 `json:"similarity_score"`
	Metadata        string  `json:"metadata"`
	CreatedAt       int64   `json:"created_at"`
	FilePath        string  `json:"file_path"`
	WorkspaceID     string  `json:"workspace_id"`
}

// Get all relationships for an entity
func (q *Queries) GetEntityRelations(ctx context.Context, entityName string) ([]GetEntityRelationsRow, error) {
	rows, err := q.query(ctx, q.getEntityRelationsStmt, getEntityRelations, entityName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEntityRelationsRow{}
	for rows.Next() {
		var i GetEntityRelationsRow
		if err := rows.Scan(
			&i.ID,
			&i.EntityName,
			&i.FileID,
			&i.RelationType,
			&i.Confidence,
			&i.SimilarityScore,
			&i.Metadata,
			&i.CreatedAt,
			&i.FilePath,
			&i.WorkspaceID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFileRelations = `-- name: GetFileRelations :many
SELECT efr.id,
    efr.entity_name,
    efr.file_id,
    efr.relation_type,
    efr.confidence,
    efr.similarity_score,
    efr.metadata,
    efr.created_at,
    e.entity_type,
    e.metadata as entity_metadata
FROM entity_file_relations efr
    JOIN entities e ON efr.entity_name = e.name
WHERE efr.file_id = ?
ORDER BY efr.confidence DESC,
    efr.similarity_score DESC
`

type GetFileRelationsRow struct {
	ID              int64   `json:"id"`
	EntityName      string  `json:"entity_name"`
	FileID          string  `json:"file_id"`
	RelationType    string  `json:"relation_type"`
	Confidence      float64 `json:"confidence"`
	SimilarityScore float64 `json:"similarity_score"`
	Metadata        string  `json:"metadata"`
	CreatedAt       int64   `json:"created_at"`
	EntityType      string  `json:"entity_type"`
	EntityMetadata  string  `json:"entity_metadata"`
}

// Get all relationships for a file
func (q *Queries) GetFileRelations(ctx context.Context, fileID string) ([]GetFileRelationsRow, error) {
	rows, err := q.query(ctx, q.getFileRelationsStmt, getFileRelations, fileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetFileRelationsRow{}
	for rows.Next() {
		var i GetFileRelationsRow
		if err := rows.Scan(
			&i.ID,
			&i.EntityName,
			&i.FileID,
			&i.RelationType,
			&i.Confidence,
			&i.SimilarityScore,
			&i.Metadata,
			&i.CreatedAt,
			&i.EntityType,
			&i.EntityMetadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFilesForEntityType = `-- name: GetFilesForEntityType :many
SELECT DISTINCT f.id,
    f.workspace_id,
    f.file_path,
    f.size,
    f.mod_time,
    f.is_dir,
    f.checksum,
    f.embedding,
    f.metadata,
    f.created_at,
    f.updated_at,
    efr.relation_type,
    efr.confidence,
    efr.similarity_score
FROM files f
    JOIN entity_file_relations efr ON f.id = efr.file_id
    JOIN entities e ON efr.entity_name = e.name
WHERE e.entity_type = ?
ORDER BY efr.confidence DESC,
    f.updated_at DESC
LIMIT ? OFFSET ?
`

type GetFilesForEntityTypeParams struct {
	EntityType string `json:"entity_type"`
	Limit      int64  `json:"limit"`
	Offset     int64  `json:"offset"`
}

type GetFilesForEntityTypeRow struct {
	ID              string       `json:"id"`
	WorkspaceID     string       `json:"workspace_id"`
	FilePath        string       `json:"file_path"`
	Size            int64        `json:"size"`
	ModTime         int64        `json:"mod_time"`
	IsDir           sql.NullBool `json:"is_dir"`
	Checksum        string       `json:"checksum"`
	Embedding       interface{}  `json:"embedding"`
	Metadata        string       `json:"metadata"`
	CreatedAt       int64        `json:"created_at"`
	UpdatedAt       int64        `json:"updated_at"`
	RelationType    string       `json:"relation_type"`
	Confidence      float64      `json:"confidence"`
	SimilarityScore float64      `json:"similarity_score"`
}

// Get files related to entities of specific type
func (q *Queries) GetFilesForEntityType(ctx context.Context, arg GetFilesForEntityTypeParams) ([]GetFilesForEntityTypeRow, error) {
	rows, err := q.query(ctx, q.getFilesForEntityTypeStmt, getFilesForEntityType, arg.EntityType, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetFilesForEntityTypeRow{}
	for rows.Next() {
		var i GetFilesForEntityTypeRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.FilePath,
			&i.Size,
			&i.ModTime,
			&i.IsDir,
			&i.Checksum,
			&i.Embedding,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RelationType,
			&i.Confidence,
			&i.SimilarityScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHighConfidenceRelations = `-- name: GetHighConfidenceRelations :many
SELECT efr.id,
    efr.entity_name,
    efr.file_id,
    efr.relation_type,
    efr.confidence,
    efr.similarity_score,
    efr.metadata,
    efr.created_at
FROM entity_file_relations efr
WHERE efr.confidence >= ?
ORDER BY efr.confidence DESC,
    efr.similarity_score DESC
LIMIT ? OFFSET ?
`

type GetHighConfidenceRelationsParams struct {
	Confidence float64 `json:"confidence"`
	Limit      int64   `json:"limit"`
	Offset     int64   `json:"offset"`
}

// Get relationships above confidence threshold
func (q *Queries) GetHighConfidenceRelations(ctx context.Context, arg GetHighConfidenceRelationsParams) ([]EntityFileRelation, error) {
	rows, err := q.query(ctx, q.getHighConfidenceRelationsStmt, getHighConfidenceRelations, arg.Confidence, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EntityFileRelation{}
	for rows.Next() {
		var i EntityFileRelation
		if err := rows.Scan(
			&i.ID,
			&i.EntityName,
			&i.FileID,
			&i.RelationType,
			&i.Confidence,
			&i.SimilarityScore,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrphanedRelations = `-- name: GetOrphanedRelations :many
SELECT efr.id,
    efr.entity_name,
    efr.file_id,
    efr.relation_type,
    CASE
        WHEN e.name IS NULL THEN 'missing_entity'
        WHEN f.id IS NULL THEN 'missing_file'
        ELSE 'valid'
    END as status
FROM entity_file_relations efr
    LEFT JOIN entities e ON efr.entity_name = e.name
    LEFT JOIN files f ON efr.file_id = f.id
WHERE e.name IS NULL
    OR f.id IS NULL
`

type GetOrphanedRelationsRow struct {
	ID           int64  `json:"id"`
	EntityName   string `json:"entity_name"`
	FileID       string `json:"file_id"`
	RelationType string `json:"relation_type"`
	Status       string `json:"status"`
}

// Find relations where entity or file no longer exists
func (q *Queries) GetOrphanedRelations(ctx context.Context) ([]GetOrphanedRelationsRow, error) {
	rows, err := q.query(ctx, q.getOrphanedRelationsStmt, getOrphanedRelations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOrphanedRelationsRow{}
	for rows.Next() {
		var i GetOrphanedRelationsRow
		if err := rows.Scan(
			&i.ID,
			&i.EntityName,
			&i.FileID,
			&i.RelationType,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRelationStatistics = `-- name: GetRelationStatistics :one
SELECT COUNT(*) as total_relations,
    COUNT(DISTINCT entity_name) as unique_entities,
    COUNT(DISTINCT file_id) as unique_files,
    AVG(confidence) as avg_confidence,
    MIN(confidence) as min_confidence,
    MAX(confidence) as max_confidence,
    COUNT(
        CASE
            WHEN similarity_score IS NOT NULL THEN 1
        END
    ) as relations_with_similarity,
    AVG(similarity_score) as avg_similarity_score
FROM entity_file_relations
`

type GetRelationStatisticsRow struct {
	TotalRelations          int64           `json:"total_relations"`
	UniqueEntities          int64           `json:"unique_entities"`
	UniqueFiles             int64           `json:"unique_files"`
	AvgConfidence           sql.NullFloat64 `json:"avg_confidence"`
	MinConfidence           interface{}     `json:"min_confidence"`
	MaxConfidence           interface{}     `json:"max_confidence"`
	RelationsWithSimilarity int64           `json:"relations_with_similarity"`
	AvgSimilarityScore      sql.NullFloat64 `json:"avg_similarity_score"`
}

// Get comprehensive statistics about entity-file relationships
func (q *Queries) GetRelationStatistics(ctx context.Context) (GetRelationStatisticsRow, error) {
	row := q.queryRow(ctx, q.getRelationStatisticsStmt, getRelationStatistics)
	var i GetRelationStatisticsRow
	err := row.Scan(
		&i.TotalRelations,
		&i.UniqueEntities,
		&i.UniqueFiles,
		&i.AvgConfidence,
		&i.MinConfidence,
		&i.MaxConfidence,
		&i.RelationsWithSimilarity,
		&i.AvgSimilarityScore,
	)
	return i, err
}

const getRelationsByType = `-- name: GetRelationsByType :many
SELECT efr.id,
    efr.entity_name,
    efr.file_id,
    efr.relation_type,
    efr.confidence,
    efr.similarity_score,
    efr.metadata,
    efr.created_at,
    f.file_path,
    f.workspace_id,
    e.entity_type
FROM entity_file_relations efr
    JOIN files f ON efr.file_id = f.id
    JOIN entities e ON efr.entity_name = e.name
WHERE efr.relation_type = ?
ORDER BY efr.confidence DESC
LIMIT ? OFFSET ?
`

type GetRelationsByTypeParams struct {
	RelationType string `json:"relation_type"`
	Limit        int64  `json:"limit"`
	Offset       int64  `json:"offset"`
}

type GetRelationsByTypeRow struct {
	ID              int64   `json:"id"`
	EntityName      string  `json:"entity_name"`
	FileID          string  `json:"file_id"`
	RelationType    string  `json:"relation_type"`
	Confidence      float64 `json:"confidence"`
	SimilarityScore float64 `json:"similarity_score"`
	Metadata        string  `json:"metadata"`
	CreatedAt       int64   `json:"created_at"`
	FilePath        string  `json:"file_path"`
	WorkspaceID     string  `json:"workspace_id"`
	EntityType      string  `json:"entity_type"`
}

// Get relationships of specific type with pagination
func (q *Queries) GetRelationsByType(ctx context.Context, arg GetRelationsByTypeParams) ([]GetRelationsByTypeRow, error) {
	rows, err := q.query(ctx, q.getRelationsByTypeStmt, getRelationsByType, arg.RelationType, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRelationsByTypeRow{}
	for rows.Next() {
		var i GetRelationsByTypeRow
		if err := rows.Scan(
			&i.ID,
			&i.EntityName,
			&i.FileID,
			&i.RelationType,
			&i.Confidence,
			&i.SimilarityScore,
			&i.Metadata,
			&i.CreatedAt,
			&i.FilePath,
			&i.WorkspaceID,
			&i.EntityType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSimilarEntitiesForFile = `-- name: GetSimilarEntitiesForFile :many
SELECT e.name,
    e.entity_type,
    e.embedding,
    e.metadata,
    e.created_at,
    -- Placeholder for vector similarity calculation
    0.0 as similarity_score
FROM entities e
WHERE e.embedding IS NOT NULL
ORDER BY e.created_at DESC
LIMIT ?
`

type GetSimilarEntitiesForFileRow struct {
	Name            string      `json:"name"`
	EntityType      string      `json:"entity_type"`
	Embedding       interface{} `json:"embedding"`
	Metadata        string      `json:"metadata"`
	CreatedAt       int64       `json:"created_at"`
	SimilarityScore int64       `json:"similarity_score"`
}

// Find entities similar to a file based on embeddings (placeholder for vector similarity)
func (q *Queries) GetSimilarEntitiesForFile(ctx context.Context, limit int64) ([]GetSimilarEntitiesForFileRow, error) {
	rows, err := q.query(ctx, q.getSimilarEntitiesForFileStmt, getSimilarEntitiesForFile, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSimilarEntitiesForFileRow{}
	for rows.Next() {
		var i GetSimilarEntitiesForFileRow
		if err := rows.Scan(
			&i.Name,
			&i.EntityType,
			&i.Embedding,
			&i.Metadata,
			&i.CreatedAt,
			&i.SimilarityScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopRelatedFiles = `-- name: GetTopRelatedFiles :many
SELECT f.id,
    f.workspace_id,
    f.file_path,
    f.size,
    f.mod_time,
    efr.relation_type,
    efr.confidence,
    efr.similarity_score
FROM entity_file_relations efr
    JOIN files f ON efr.file_id = f.id
WHERE efr.entity_name = ?
ORDER BY efr.confidence DESC,
    efr.similarity_score DESC
LIMIT ?
`

type GetTopRelatedFilesParams struct {
	EntityName string `json:"entity_name"`
	Limit      int64  `json:"limit"`
}

type GetTopRelatedFilesRow struct {
	ID              string  `json:"id"`
	WorkspaceID     string  `json:"workspace_id"`
	FilePath        string  `json:"file_path"`
	Size            int64   `json:"size"`
	ModTime         int64   `json:"mod_time"`
	RelationType    string  `json:"relation_type"`
	Confidence      float64 `json:"confidence"`
	SimilarityScore float64 `json:"similarity_score"`
}

// Get files most related to an entity with ranking
func (q *Queries) GetTopRelatedFiles(ctx context.Context, arg GetTopRelatedFilesParams) ([]GetTopRelatedFilesRow, error) {
	rows, err := q.query(ctx, q.getTopRelatedFilesStmt, getTopRelatedFiles, arg.EntityName, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTopRelatedFilesRow{}
	for rows.Next() {
		var i GetTopRelatedFilesRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.FilePath,
			&i.Size,
			&i.ModTime,
			&i.RelationType,
			&i.Confidence,
			&i.SimilarityScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEntityFileRelation = `-- name: UpdateEntityFileRelation :one
UPDATE entity_file_relations
SET confidence = ?,
    similarity_score = ?,
    metadata = ?
WHERE id = ?
RETURNING id,
    entity_name,
    file_id,
    relation_type,
    confidence,
    similarity_score,
    metadata,
    created_at
`

type UpdateEntityFileRelationParams struct {
	Confidence      float64 `json:"confidence"`
	SimilarityScore float64 `json:"similarity_score"`
	Metadata        string  `json:"metadata"`
	ID              int64   `json:"id"`
}

// Update relationship confidence and metadata
func (q *Queries) UpdateEntityFileRelation(ctx context.Context, arg UpdateEntityFileRelationParams) (EntityFileRelation, error) {
	row := q.queryRow(ctx, q.updateEntityFileRelationStmt, updateEntityFileRelation,
		arg.Confidence,
		arg.SimilarityScore,
		arg.Metadata,
		arg.ID,
	)
	var i EntityFileRelation
	err := row.Scan(
		&i.ID,
		&i.EntityName,
		&i.FileID,
		&i.RelationType,
		&i.Confidence,
		&i.SimilarityScore,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}
