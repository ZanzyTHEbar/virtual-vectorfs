// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: operations.sql

package database

import (
	"context"
)

const batchCreateOperations = `-- name: BatchCreateOperations :exec
INSERT INTO operation_history (
        id,
        workspace_id,
        operation_type,
        entity_path,
        old_path,
        new_path,
        metadata,
        performed_by,
        performed_at
    )
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type BatchCreateOperationsParams struct {
	ID            string `json:"id"`
	WorkspaceID   string `json:"workspace_id"`
	OperationType string `json:"operation_type"`
	EntityPath    string `json:"entity_path"`
	OldPath       string `json:"old_path"`
	NewPath       string `json:"new_path"`
	Metadata      string `json:"metadata"`
	PerformedBy   string `json:"performed_by"`
	PerformedAt   int64  `json:"performed_at"`
}

// Batch create multiple operation records
func (q *Queries) BatchCreateOperations(ctx context.Context, arg BatchCreateOperationsParams) error {
	_, err := q.exec(ctx, q.batchCreateOperationsStmt, batchCreateOperations,
		arg.ID,
		arg.WorkspaceID,
		arg.OperationType,
		arg.EntityPath,
		arg.OldPath,
		arg.NewPath,
		arg.Metadata,
		arg.PerformedBy,
		arg.PerformedAt,
	)
	return err
}

const cleanupOldOperations = `-- name: CleanupOldOperations :exec
DELETE FROM operation_history
WHERE performed_at < ?
`

// Remove operations older than specified date
func (q *Queries) CleanupOldOperations(ctx context.Context, performedAt int64) error {
	_, err := q.exec(ctx, q.cleanupOldOperationsStmt, cleanupOldOperations, performedAt)
	return err
}

const createOperation = `-- name: CreateOperation :one
INSERT INTO operation_history (
        id,
        workspace_id,
        operation_type,
        entity_path,
        old_path,
        new_path,
        metadata,
        performed_by,
        performed_at
    )
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id,
    workspace_id,
    operation_type,
    entity_path,
    old_path,
    new_path,
    metadata,
    performed_by,
    performed_at
`

type CreateOperationParams struct {
	ID            string `json:"id"`
	WorkspaceID   string `json:"workspace_id"`
	OperationType string `json:"operation_type"`
	EntityPath    string `json:"entity_path"`
	OldPath       string `json:"old_path"`
	NewPath       string `json:"new_path"`
	Metadata      string `json:"metadata"`
	PerformedBy   string `json:"performed_by"`
	PerformedAt   int64  `json:"performed_at"`
}

// Create a new operation history entry
func (q *Queries) CreateOperation(ctx context.Context, arg CreateOperationParams) (OperationHistory, error) {
	row := q.queryRow(ctx, q.createOperationStmt, createOperation,
		arg.ID,
		arg.WorkspaceID,
		arg.OperationType,
		arg.EntityPath,
		arg.OldPath,
		arg.NewPath,
		arg.Metadata,
		arg.PerformedBy,
		arg.PerformedAt,
	)
	var i OperationHistory
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.OperationType,
		&i.EntityPath,
		&i.OldPath,
		&i.NewPath,
		&i.Metadata,
		&i.PerformedBy,
		&i.PerformedAt,
	)
	return i, err
}

const createSnapshot = `-- name: CreateSnapshot :one
INSERT INTO snapshots (
        id,
        workspace_id,
        taken_at,
        directory_state,
        description,
        created_at
    )
VALUES (?, ?, ?, ?, ?, ?)
RETURNING id,
    workspace_id,
    taken_at,
    directory_state,
    description,
    created_at
`

type CreateSnapshotParams struct {
	ID             string `json:"id"`
	WorkspaceID    string `json:"workspace_id"`
	TakenAt        int64  `json:"taken_at"`
	DirectoryState []byte `json:"directory_state"`
	Description    string `json:"description"`
	CreatedAt      int64  `json:"created_at"`
}

type CreateSnapshotRow struct {
	ID             string `json:"id"`
	WorkspaceID    string `json:"workspace_id"`
	TakenAt        int64  `json:"taken_at"`
	DirectoryState []byte `json:"directory_state"`
	Description    string `json:"description"`
	CreatedAt      int64  `json:"created_at"`
}

// Create a new snapshot for a workspace
func (q *Queries) CreateSnapshot(ctx context.Context, arg CreateSnapshotParams) (CreateSnapshotRow, error) {
	row := q.queryRow(ctx, q.createSnapshotStmt, createSnapshot,
		arg.ID,
		arg.WorkspaceID,
		arg.TakenAt,
		arg.DirectoryState,
		arg.Description,
		arg.CreatedAt,
	)
	var i CreateSnapshotRow
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.TakenAt,
		&i.DirectoryState,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const deleteSnapshot = `-- name: DeleteSnapshot :exec
DELETE FROM snapshots
WHERE id = ?
`

// Delete snapshot by ID
func (q *Queries) DeleteSnapshot(ctx context.Context, id string) error {
	_, err := q.exec(ctx, q.deleteSnapshotStmt, deleteSnapshot, id)
	return err
}

const getLatestSnapshot = `-- name: GetLatestSnapshot :one
SELECT id,
    workspace_id,
    taken_at,
    directory_state,
    description,
    created_at
FROM snapshots
WHERE workspace_id = ?
ORDER BY taken_at DESC
LIMIT 1
`

type GetLatestSnapshotRow struct {
	ID             string `json:"id"`
	WorkspaceID    string `json:"workspace_id"`
	TakenAt        int64  `json:"taken_at"`
	DirectoryState []byte `json:"directory_state"`
	Description    string `json:"description"`
	CreatedAt      int64  `json:"created_at"`
}

// Get the most recent snapshot for a workspace
func (q *Queries) GetLatestSnapshot(ctx context.Context, workspaceID string) (GetLatestSnapshotRow, error) {
	row := q.queryRow(ctx, q.getLatestSnapshotStmt, getLatestSnapshot, workspaceID)
	var i GetLatestSnapshotRow
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.TakenAt,
		&i.DirectoryState,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const getOperation = `-- name: GetOperation :one
SELECT id,
    workspace_id,
    operation_type,
    entity_path,
    old_path,
    new_path,
    metadata,
    performed_by,
    performed_at
FROM operation_history
WHERE id = ?
`

// Get operation by ID
func (q *Queries) GetOperation(ctx context.Context, id string) (OperationHistory, error) {
	row := q.queryRow(ctx, q.getOperationStmt, getOperation, id)
	var i OperationHistory
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.OperationType,
		&i.EntityPath,
		&i.OldPath,
		&i.NewPath,
		&i.Metadata,
		&i.PerformedBy,
		&i.PerformedAt,
	)
	return i, err
}

const getOperationStats = `-- name: GetOperationStats :one
SELECT COUNT(*) as total_operations,
    COUNT(DISTINCT operation_type) as unique_operation_types,
    COUNT(DISTINCT performed_by) as unique_users,
    MIN(performed_at) as first_operation,
    MAX(performed_at) as latest_operation
FROM operation_history
WHERE workspace_id = ?
`

type GetOperationStatsRow struct {
	TotalOperations      int64       `json:"total_operations"`
	UniqueOperationTypes int64       `json:"unique_operation_types"`
	UniqueUsers          int64       `json:"unique_users"`
	FirstOperation       interface{} `json:"first_operation"`
	LatestOperation      interface{} `json:"latest_operation"`
}

// Get operation statistics for a workspace
func (q *Queries) GetOperationStats(ctx context.Context, workspaceID string) (GetOperationStatsRow, error) {
	row := q.queryRow(ctx, q.getOperationStatsStmt, getOperationStats, workspaceID)
	var i GetOperationStatsRow
	err := row.Scan(
		&i.TotalOperations,
		&i.UniqueOperationTypes,
		&i.UniqueUsers,
		&i.FirstOperation,
		&i.LatestOperation,
	)
	return i, err
}

const getOperationSummary = `-- name: GetOperationSummary :many
SELECT operation_type,
    performed_by,
    COUNT(*) as operation_count,
    MIN(performed_at) as first_operation,
    MAX(performed_at) as last_operation
FROM operation_history
WHERE workspace_id = ?
GROUP BY operation_type,
    performed_by
ORDER BY operation_count DESC
`

type GetOperationSummaryRow struct {
	OperationType  string      `json:"operation_type"`
	PerformedBy    string      `json:"performed_by"`
	OperationCount int64       `json:"operation_count"`
	FirstOperation interface{} `json:"first_operation"`
	LastOperation  interface{} `json:"last_operation"`
}

// Get operation summary by type and user
func (q *Queries) GetOperationSummary(ctx context.Context, workspaceID string) ([]GetOperationSummaryRow, error) {
	rows, err := q.query(ctx, q.getOperationSummaryStmt, getOperationSummary, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOperationSummaryRow{}
	for rows.Next() {
		var i GetOperationSummaryRow
		if err := rows.Scan(
			&i.OperationType,
			&i.PerformedBy,
			&i.OperationCount,
			&i.FirstOperation,
			&i.LastOperation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOperationsByTimeRange = `-- name: GetOperationsByTimeRange :many
SELECT id,
    workspace_id,
    operation_type,
    entity_path,
    old_path,
    new_path,
    metadata,
    performed_by,
    performed_at
FROM operation_history
WHERE performed_at >= ?
    AND performed_at <= ?
ORDER BY performed_at DESC
LIMIT ? OFFSET ?
`

type GetOperationsByTimeRangeParams struct {
	PerformedAt   int64 `json:"performed_at"`
	PerformedAt_2 int64 `json:"performed_at_2"`
	Limit         int64 `json:"limit"`
	Offset        int64 `json:"offset"`
}

// Get operations within a time range
func (q *Queries) GetOperationsByTimeRange(ctx context.Context, arg GetOperationsByTimeRangeParams) ([]OperationHistory, error) {
	rows, err := q.query(ctx, q.getOperationsByTimeRangeStmt, getOperationsByTimeRange,
		arg.PerformedAt,
		arg.PerformedAt_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OperationHistory{}
	for rows.Next() {
		var i OperationHistory
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.OperationType,
			&i.EntityPath,
			&i.OldPath,
			&i.NewPath,
			&i.Metadata,
			&i.PerformedBy,
			&i.PerformedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOperationsByType = `-- name: GetOperationsByType :many
SELECT id,
    workspace_id,
    operation_type,
    entity_path,
    old_path,
    new_path,
    metadata,
    performed_by,
    performed_at
FROM operation_history
WHERE operation_type = ?
ORDER BY performed_at DESC
LIMIT ? OFFSET ?
`

type GetOperationsByTypeParams struct {
	OperationType string `json:"operation_type"`
	Limit         int64  `json:"limit"`
	Offset        int64  `json:"offset"`
}

// Get operations of a specific type
func (q *Queries) GetOperationsByType(ctx context.Context, arg GetOperationsByTypeParams) ([]OperationHistory, error) {
	rows, err := q.query(ctx, q.getOperationsByTypeStmt, getOperationsByType, arg.OperationType, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OperationHistory{}
	for rows.Next() {
		var i OperationHistory
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.OperationType,
			&i.EntityPath,
			&i.OldPath,
			&i.NewPath,
			&i.Metadata,
			&i.PerformedBy,
			&i.PerformedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOperationsByUser = `-- name: GetOperationsByUser :many
SELECT id,
    workspace_id,
    operation_type,
    entity_path,
    old_path,
    new_path,
    metadata,
    performed_by,
    performed_at
FROM operation_history
WHERE performed_by = ?
ORDER BY performed_at DESC
LIMIT ? OFFSET ?
`

type GetOperationsByUserParams struct {
	PerformedBy string `json:"performed_by"`
	Limit       int64  `json:"limit"`
	Offset      int64  `json:"offset"`
}

// Get operations performed by a specific user
func (q *Queries) GetOperationsByUser(ctx context.Context, arg GetOperationsByUserParams) ([]OperationHistory, error) {
	rows, err := q.query(ctx, q.getOperationsByUserStmt, getOperationsByUser, arg.PerformedBy, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OperationHistory{}
	for rows.Next() {
		var i OperationHistory
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.OperationType,
			&i.EntityPath,
			&i.OldPath,
			&i.NewPath,
			&i.Metadata,
			&i.PerformedBy,
			&i.PerformedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentOperations = `-- name: GetRecentOperations :many
SELECT id,
    workspace_id,
    operation_type,
    entity_path,
    old_path,
    new_path,
    metadata,
    performed_by,
    performed_at
FROM operation_history
ORDER BY performed_at DESC
LIMIT ? OFFSET ?
`

type GetRecentOperationsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

// Get recent operations across all workspaces
func (q *Queries) GetRecentOperations(ctx context.Context, arg GetRecentOperationsParams) ([]OperationHistory, error) {
	rows, err := q.query(ctx, q.getRecentOperationsStmt, getRecentOperations, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OperationHistory{}
	for rows.Next() {
		var i OperationHistory
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.OperationType,
			&i.EntityPath,
			&i.OldPath,
			&i.NewPath,
			&i.Metadata,
			&i.PerformedBy,
			&i.PerformedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSnapshot = `-- name: GetSnapshot :one
SELECT id,
    workspace_id,
    taken_at,
    directory_state,
    description,
    created_at
FROM snapshots
WHERE id = ?
`

type GetSnapshotRow struct {
	ID             string `json:"id"`
	WorkspaceID    string `json:"workspace_id"`
	TakenAt        int64  `json:"taken_at"`
	DirectoryState []byte `json:"directory_state"`
	Description    string `json:"description"`
	CreatedAt      int64  `json:"created_at"`
}

// Get snapshot by ID
func (q *Queries) GetSnapshot(ctx context.Context, id string) (GetSnapshotRow, error) {
	row := q.queryRow(ctx, q.getSnapshotStmt, getSnapshot, id)
	var i GetSnapshotRow
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.TakenAt,
		&i.DirectoryState,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const getWorkspaceOperations = `-- name: GetWorkspaceOperations :many
SELECT id,
    workspace_id,
    operation_type,
    entity_path,
    old_path,
    new_path,
    metadata,
    performed_by,
    performed_at
FROM operation_history
WHERE workspace_id = ?
ORDER BY performed_at DESC
LIMIT ? OFFSET ?
`

type GetWorkspaceOperationsParams struct {
	WorkspaceID string `json:"workspace_id"`
	Limit       int64  `json:"limit"`
	Offset      int64  `json:"offset"`
}

// Get operation history for a workspace
func (q *Queries) GetWorkspaceOperations(ctx context.Context, arg GetWorkspaceOperationsParams) ([]OperationHistory, error) {
	rows, err := q.query(ctx, q.getWorkspaceOperationsStmt, getWorkspaceOperations, arg.WorkspaceID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OperationHistory{}
	for rows.Next() {
		var i OperationHistory
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.OperationType,
			&i.EntityPath,
			&i.OldPath,
			&i.NewPath,
			&i.Metadata,
			&i.PerformedBy,
			&i.PerformedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorkspaceSnapshots = `-- name: GetWorkspaceSnapshots :many
SELECT id,
    workspace_id,
    taken_at,
    directory_state,
    description,
    created_at
FROM snapshots
WHERE workspace_id = ?
ORDER BY taken_at DESC
`

type GetWorkspaceSnapshotsRow struct {
	ID             string `json:"id"`
	WorkspaceID    string `json:"workspace_id"`
	TakenAt        int64  `json:"taken_at"`
	DirectoryState []byte `json:"directory_state"`
	Description    string `json:"description"`
	CreatedAt      int64  `json:"created_at"`
}

// Get all snapshots for a workspace
func (q *Queries) GetWorkspaceSnapshots(ctx context.Context, workspaceID string) ([]GetWorkspaceSnapshotsRow, error) {
	rows, err := q.query(ctx, q.getWorkspaceSnapshotsStmt, getWorkspaceSnapshots, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetWorkspaceSnapshotsRow{}
	for rows.Next() {
		var i GetWorkspaceSnapshotsRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.TakenAt,
			&i.DirectoryState,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
