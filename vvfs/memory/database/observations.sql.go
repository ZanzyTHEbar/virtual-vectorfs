// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: observations.sql

package database

import (
	"context"
	"database/sql"
)

const batchCreateObservations = `-- name: BatchCreateObservations :exec
INSERT INTO observations (entity_name, content, embedding, created_at)
VALUES (?, ?, ?, ?)
`

type BatchCreateObservationsParams struct {
	EntityName string      `json:"entity_name"`
	Content    string      `json:"content"`
	Embedding  interface{} `json:"embedding"`
	CreatedAt  int64       `json:"created_at"`
}

// Batch create multiple observations
func (q *Queries) BatchCreateObservations(ctx context.Context, arg BatchCreateObservationsParams) error {
	_, err := q.exec(ctx, q.batchCreateObservationsStmt, batchCreateObservations,
		arg.EntityName,
		arg.Content,
		arg.Embedding,
		arg.CreatedAt,
	)
	return err
}

const batchDeleteObservations = `-- name: BatchDeleteObservations :exec
DELETE FROM observations
WHERE id = ?
`

// Batch delete multiple observations
func (q *Queries) BatchDeleteObservations(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.batchDeleteObservationsStmt, batchDeleteObservations, id)
	return err
}

const batchUpdateObservations = `-- name: BatchUpdateObservations :exec
UPDATE observations
SET content = ?,
    embedding = ?
WHERE id = ?
`

type BatchUpdateObservationsParams struct {
	Content   string      `json:"content"`
	Embedding interface{} `json:"embedding"`
	ID        int64       `json:"id"`
}

// Batch update multiple observations
func (q *Queries) BatchUpdateObservations(ctx context.Context, arg BatchUpdateObservationsParams) error {
	_, err := q.exec(ctx, q.batchUpdateObservationsStmt, batchUpdateObservations, arg.Content, arg.Embedding, arg.ID)
	return err
}

const createObservation = `-- name: CreateObservation :one
INSERT INTO observations (entity_name, content, embedding, created_at)
VALUES (?, ?, ?, ?)
RETURNING id,
    entity_name,
    content,
    embedding,
    created_at
`

type CreateObservationParams struct {
	EntityName string      `json:"entity_name"`
	Content    string      `json:"content"`
	Embedding  interface{} `json:"embedding"`
	CreatedAt  int64       `json:"created_at"`
}

// Create a new observation for an entity
func (q *Queries) CreateObservation(ctx context.Context, arg CreateObservationParams) (Observation, error) {
	row := q.queryRow(ctx, q.createObservationStmt, createObservation,
		arg.EntityName,
		arg.Content,
		arg.Embedding,
		arg.CreatedAt,
	)
	var i Observation
	err := row.Scan(
		&i.ID,
		&i.EntityName,
		&i.Content,
		&i.Embedding,
		&i.CreatedAt,
	)
	return i, err
}

const deleteEntityObservations = `-- name: DeleteEntityObservations :exec
DELETE FROM observations
WHERE entity_name = ?
`

// Delete all observations for an entity
func (q *Queries) DeleteEntityObservations(ctx context.Context, entityName string) error {
	_, err := q.exec(ctx, q.deleteEntityObservationsStmt, deleteEntityObservations, entityName)
	return err
}

const deleteObservation = `-- name: DeleteObservation :exec
DELETE FROM observations
WHERE id = ?
`

// Delete observation by ID
func (q *Queries) DeleteObservation(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.deleteObservationStmt, deleteObservation, id)
	return err
}

const getEntityObservationStats = `-- name: GetEntityObservationStats :one
SELECT COUNT(*) as total_observations,
    AVG(LENGTH(content)) as avg_content_length,
    MIN(created_at) as first_observation,
    MAX(created_at) as latest_observation,
    COUNT(
        CASE
            WHEN embedding IS NOT NULL THEN 1
        END
    ) as observations_with_embeddings
FROM observations
WHERE entity_name = ?
`

type GetEntityObservationStatsRow struct {
	TotalObservations          int64           `json:"total_observations"`
	AvgContentLength           sql.NullFloat64 `json:"avg_content_length"`
	FirstObservation           interface{}     `json:"first_observation"`
	LatestObservation          interface{}     `json:"latest_observation"`
	ObservationsWithEmbeddings int64           `json:"observations_with_embeddings"`
}

// Get observation statistics for an entity
func (q *Queries) GetEntityObservationStats(ctx context.Context, entityName string) (GetEntityObservationStatsRow, error) {
	row := q.queryRow(ctx, q.getEntityObservationStatsStmt, getEntityObservationStats, entityName)
	var i GetEntityObservationStatsRow
	err := row.Scan(
		&i.TotalObservations,
		&i.AvgContentLength,
		&i.FirstObservation,
		&i.LatestObservation,
		&i.ObservationsWithEmbeddings,
	)
	return i, err
}

const getEntityObservations = `-- name: GetEntityObservations :many
SELECT id,
    entity_name,
    content,
    embedding,
    created_at
FROM observations
WHERE entity_name = ?
ORDER BY created_at DESC
`

// Get all observations for an entity
func (q *Queries) GetEntityObservations(ctx context.Context, entityName string) ([]Observation, error) {
	rows, err := q.query(ctx, q.getEntityObservationsStmt, getEntityObservations, entityName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Observation{}
	for rows.Next() {
		var i Observation
		if err := rows.Scan(
			&i.ID,
			&i.EntityName,
			&i.Content,
			&i.Embedding,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getObservation = `-- name: GetObservation :one
SELECT id,
    entity_name,
    content,
    embedding,
    created_at
FROM observations
WHERE id = ?
`

// Get observation by ID
func (q *Queries) GetObservation(ctx context.Context, id int64) (Observation, error) {
	row := q.queryRow(ctx, q.getObservationStmt, getObservation, id)
	var i Observation
	err := row.Scan(
		&i.ID,
		&i.EntityName,
		&i.Content,
		&i.Embedding,
		&i.CreatedAt,
	)
	return i, err
}

const getObservationsByEntities = `-- name: GetObservationsByEntities :many
SELECT o.id,
    o.entity_name,
    o.content,
    o.embedding,
    o.created_at
FROM observations o
WHERE o.entity_name IN (?, ?, ?) -- Placeholder for dynamic IN clause
ORDER BY o.entity_name,
    o.created_at DESC
`

type GetObservationsByEntitiesParams struct {
	EntityName   string `json:"entity_name"`
	EntityName_2 string `json:"entity_name_2"`
	EntityName_3 string `json:"entity_name_3"`
}

// Get observations for multiple entities
func (q *Queries) GetObservationsByEntities(ctx context.Context, arg GetObservationsByEntitiesParams) ([]Observation, error) {
	rows, err := q.query(ctx, q.getObservationsByEntitiesStmt, getObservationsByEntities, arg.EntityName, arg.EntityName_2, arg.EntityName_3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Observation{}
	for rows.Next() {
		var i Observation
		if err := rows.Scan(
			&i.ID,
			&i.EntityName,
			&i.Content,
			&i.Embedding,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getObservationsByTimeRange = `-- name: GetObservationsByTimeRange :many
SELECT id,
    entity_name,
    content,
    embedding,
    created_at
FROM observations
WHERE created_at >= ?
    AND created_at <= ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type GetObservationsByTimeRangeParams struct {
	CreatedAt   int64 `json:"created_at"`
	CreatedAt_2 int64 `json:"created_at_2"`
	Limit       int64 `json:"limit"`
	Offset      int64 `json:"offset"`
}

// Get observations within a time range
func (q *Queries) GetObservationsByTimeRange(ctx context.Context, arg GetObservationsByTimeRangeParams) ([]Observation, error) {
	rows, err := q.query(ctx, q.getObservationsByTimeRangeStmt, getObservationsByTimeRange,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Observation{}
	for rows.Next() {
		var i Observation
		if err := rows.Scan(
			&i.ID,
			&i.EntityName,
			&i.Content,
			&i.Embedding,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getObservationsWithEmbeddings = `-- name: GetObservationsWithEmbeddings :many
SELECT id,
    entity_name,
    content,
    embedding,
    created_at
FROM observations
WHERE embedding IS NOT NULL
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type GetObservationsWithEmbeddingsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

// Get observations that have embeddings for vector search
func (q *Queries) GetObservationsWithEmbeddings(ctx context.Context, arg GetObservationsWithEmbeddingsParams) ([]Observation, error) {
	rows, err := q.query(ctx, q.getObservationsWithEmbeddingsStmt, getObservationsWithEmbeddings, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Observation{}
	for rows.Next() {
		var i Observation
		if err := rows.Scan(
			&i.ID,
			&i.EntityName,
			&i.Content,
			&i.Embedding,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentObservations = `-- name: GetRecentObservations :many
SELECT id,
    entity_name,
    content,
    embedding,
    created_at
FROM observations
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type GetRecentObservationsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

// Get recent observations across all entities
func (q *Queries) GetRecentObservations(ctx context.Context, arg GetRecentObservationsParams) ([]Observation, error) {
	rows, err := q.query(ctx, q.getRecentObservationsStmt, getRecentObservations, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Observation{}
	for rows.Next() {
		var i Observation
		if err := rows.Scan(
			&i.ID,
			&i.EntityName,
			&i.Content,
			&i.Embedding,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchObservations = `-- name: SearchObservations :many
SELECT o.id,
    o.entity_name,
    o.content,
    o.embedding,
    o.created_at
FROM observations o
WHERE o.content LIKE '%' || ? || '%'
    OR o.entity_name LIKE '%' || ? || '%'
ORDER BY o.created_at DESC
LIMIT ? OFFSET ?
`

type SearchObservationsParams struct {
	Column1 sql.NullString `json:"column_1"`
	Column2 sql.NullString `json:"column_2"`
	Limit   int64          `json:"limit"`
	Offset  int64          `json:"offset"`
}

// Search observations by content (basic LIKE search)
func (q *Queries) SearchObservations(ctx context.Context, arg SearchObservationsParams) ([]Observation, error) {
	rows, err := q.query(ctx, q.searchObservationsStmt, searchObservations,
		arg.Column1,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Observation{}
	for rows.Next() {
		var i Observation
		if err := rows.Scan(
			&i.ID,
			&i.EntityName,
			&i.Content,
			&i.Embedding,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateObservation = `-- name: UpdateObservation :one
UPDATE observations
SET content = ?,
    embedding = ?
WHERE id = ?
RETURNING id,
    entity_name,
    content,
    embedding,
    created_at
`

type UpdateObservationParams struct {
	Content   string      `json:"content"`
	Embedding interface{} `json:"embedding"`
	ID        int64       `json:"id"`
}

// Update observation content and embedding
func (q *Queries) UpdateObservation(ctx context.Context, arg UpdateObservationParams) (Observation, error) {
	row := q.queryRow(ctx, q.updateObservationStmt, updateObservation, arg.Content, arg.Embedding, arg.ID)
	var i Observation
	err := row.Scan(
		&i.ID,
		&i.EntityName,
		&i.Content,
		&i.Embedding,
		&i.CreatedAt,
	)
	return i, err
}
