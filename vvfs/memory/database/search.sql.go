// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: search.sql

package database

import (
	"context"
	"database/sql"
)

const getEntitiesByMetadata = `-- name: GetEntitiesByMetadata :many
SELECT name,
    entity_type,
    embedding,
    metadata,
    created_at,
    updated_at
FROM entities
WHERE metadata LIKE '%' || ? || '%'
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type GetEntitiesByMetadataParams struct {
	Column1 sql.NullString `json:"column_1"`
	Limit   int64          `json:"limit"`
	Offset  int64          `json:"offset"`
}

// Search entities by metadata content
func (q *Queries) GetEntitiesByMetadata(ctx context.Context, arg GetEntitiesByMetadataParams) ([]Entity, error) {
	rows, err := q.query(ctx, q.getEntitiesByMetadataStmt, getEntitiesByMetadata, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Entity{}
	for rows.Next() {
		var i Entity
		if err := rows.Scan(
			&i.Name,
			&i.EntityType,
			&i.Embedding,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEntitiesByObservationCount = `-- name: GetEntitiesByObservationCount :many
SELECT e.name,
    e.entity_type,
    e.embedding,
    e.metadata,
    e.created_at,
    e.updated_at,
    COUNT(o.id) as observation_count
FROM entities e
    LEFT JOIN observations o ON o.entity_name = e.name
GROUP BY e.name,
    e.entity_type,
    e.embedding,
    e.metadata,
    e.created_at,
    e.updated_at
ORDER BY observation_count DESC,
    e.created_at DESC
LIMIT ? OFFSET ?
`

type GetEntitiesByObservationCountParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

type GetEntitiesByObservationCountRow struct {
	Name             string      `json:"name"`
	EntityType       string      `json:"entity_type"`
	Embedding        interface{} `json:"embedding"`
	Metadata         string      `json:"metadata"`
	CreatedAt        int64       `json:"created_at"`
	UpdatedAt        int64       `json:"updated_at"`
	ObservationCount int64       `json:"observation_count"`
}

// Get entities ordered by number of observations
func (q *Queries) GetEntitiesByObservationCount(ctx context.Context, arg GetEntitiesByObservationCountParams) ([]GetEntitiesByObservationCountRow, error) {
	rows, err := q.query(ctx, q.getEntitiesByObservationCountStmt, getEntitiesByObservationCount, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEntitiesByObservationCountRow{}
	for rows.Next() {
		var i GetEntitiesByObservationCountRow
		if err := rows.Scan(
			&i.Name,
			&i.EntityType,
			&i.Embedding,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ObservationCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEntitiesWithEmbeddings = `-- name: GetEntitiesWithEmbeddings :many
SELECT name,
    entity_type,
    embedding,
    metadata,
    created_at,
    updated_at
FROM entities
WHERE embedding IS NOT NULL
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type GetEntitiesWithEmbeddingsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

// Get entities that have embeddings for vector operations
func (q *Queries) GetEntitiesWithEmbeddings(ctx context.Context, arg GetEntitiesWithEmbeddingsParams) ([]Entity, error) {
	rows, err := q.query(ctx, q.getEntitiesWithEmbeddingsStmt, getEntitiesWithEmbeddings, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Entity{}
	for rows.Next() {
		var i Entity
		if err := rows.Scan(
			&i.Name,
			&i.EntityType,
			&i.Embedding,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentEntities = `-- name: GetRecentEntities :many
SELECT name,
    entity_type,
    embedding,
    metadata,
    created_at,
    updated_at
FROM entities
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type GetRecentEntitiesParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

// Get recently created entities
func (q *Queries) GetRecentEntities(ctx context.Context, arg GetRecentEntitiesParams) ([]Entity, error) {
	rows, err := q.query(ctx, q.getRecentEntitiesStmt, getRecentEntities, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Entity{}
	for rows.Next() {
		var i Entity
		if err := rows.Scan(
			&i.Name,
			&i.EntityType,
			&i.Embedding,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchEntitiesByContent = `-- name: SearchEntitiesByContent :many
SELECT DISTINCT e.name,
    e.entity_type,
    e.embedding,
    e.metadata,
    e.created_at,
    e.updated_at
FROM entities e
    JOIN observations o ON o.entity_name = e.name
WHERE o.content LIKE '%' || ? || '%'
ORDER BY e.created_at DESC
LIMIT ? OFFSET ?
`

type SearchEntitiesByContentParams struct {
	Column1 sql.NullString `json:"column_1"`
	Limit   int64          `json:"limit"`
	Offset  int64          `json:"offset"`
}

// Search entities by observation content
func (q *Queries) SearchEntitiesByContent(ctx context.Context, arg SearchEntitiesByContentParams) ([]Entity, error) {
	rows, err := q.query(ctx, q.searchEntitiesByContentStmt, searchEntitiesByContent, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Entity{}
	for rows.Next() {
		var i Entity
		if err := rows.Scan(
			&i.Name,
			&i.EntityType,
			&i.Embedding,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchEntitiesByName = `-- name: SearchEntitiesByName :many
SELECT name,
    entity_type,
    e.embedding,
    metadata,
    created_at,
    updated_at
FROM entities e
WHERE name LIKE '%' || ? || '%'
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type SearchEntitiesByNameParams struct {
	Column1 sql.NullString `json:"column_1"`
	Limit   int64          `json:"limit"`
	Offset  int64          `json:"offset"`
}

// Search entities by name
func (q *Queries) SearchEntitiesByName(ctx context.Context, arg SearchEntitiesByNameParams) ([]Entity, error) {
	rows, err := q.query(ctx, q.searchEntitiesByNameStmt, searchEntitiesByName, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Entity{}
	for rows.Next() {
		var i Entity
		if err := rows.Scan(
			&i.Name,
			&i.EntityType,
			&i.Embedding,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchEntitiesByType = `-- name: SearchEntitiesByType :many
SELECT name,
    entity_type,
    e.embedding,
    metadata,
    created_at,
    updated_at
FROM entities e
WHERE entity_type = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type SearchEntitiesByTypeParams struct {
	EntityType string `json:"entity_type"`
	Limit      int64  `json:"limit"`
	Offset     int64  `json:"offset"`
}

// Search entities by type
func (q *Queries) SearchEntitiesByType(ctx context.Context, arg SearchEntitiesByTypeParams) ([]Entity, error) {
	rows, err := q.query(ctx, q.searchEntitiesByTypeStmt, searchEntitiesByType, arg.EntityType, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Entity{}
	for rows.Next() {
		var i Entity
		if err := rows.Scan(
			&i.Name,
			&i.EntityType,
			&i.Embedding,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
