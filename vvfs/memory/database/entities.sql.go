// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: entities.sql

package database

import (
	"context"
	"database/sql"
)

const batchCreateEntities = `-- name: BatchCreateEntities :exec
INSERT INTO entities (
        name,
        entity_type,
        embedding,
        metadata,
        created_at,
        updated_at
    )
VALUES (?, ?, ?, ?, ?, ?)
`

type BatchCreateEntitiesParams struct {
	Name       string      `json:"name"`
	EntityType string      `json:"entity_type"`
	Embedding  interface{} `json:"embedding"`
	Metadata   string      `json:"metadata"`
	CreatedAt  int64       `json:"created_at"`
	UpdatedAt  int64       `json:"updated_at"`
}

// Batch insert multiple entities
func (q *Queries) BatchCreateEntities(ctx context.Context, arg BatchCreateEntitiesParams) error {
	_, err := q.exec(ctx, q.batchCreateEntitiesStmt, batchCreateEntities,
		arg.Name,
		arg.EntityType,
		arg.Embedding,
		arg.Metadata,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const batchDeleteEntities = `-- name: BatchDeleteEntities :exec
DELETE FROM entities
WHERE name = ?
`

// Batch delete multiple entities
func (q *Queries) BatchDeleteEntities(ctx context.Context, name string) error {
	_, err := q.exec(ctx, q.batchDeleteEntitiesStmt, batchDeleteEntities, name)
	return err
}

const batchUpdateEntities = `-- name: BatchUpdateEntities :exec
UPDATE entities
SET entity_type = ?,
    embedding = ?,
    metadata = ?,
    updated_at = ?
WHERE name = ?
`

type BatchUpdateEntitiesParams struct {
	EntityType string      `json:"entity_type"`
	Embedding  interface{} `json:"embedding"`
	Metadata   string      `json:"metadata"`
	UpdatedAt  int64       `json:"updated_at"`
	Name       string      `json:"name"`
}

// Batch update multiple entities
func (q *Queries) BatchUpdateEntities(ctx context.Context, arg BatchUpdateEntitiesParams) error {
	_, err := q.exec(ctx, q.batchUpdateEntitiesStmt, batchUpdateEntities,
		arg.EntityType,
		arg.Embedding,
		arg.Metadata,
		arg.UpdatedAt,
		arg.Name,
	)
	return err
}

const createEntity = `-- name: CreateEntity :one
INSERT INTO entities (
        name,
        entity_type,
        embedding,
        metadata,
        created_at,
        updated_at
    )
VALUES (?, ?, ?, ?, ?, ?) ON CONFLICT(name) DO
UPDATE
SET entity_type = excluded.entity_type,
    embedding = excluded.embedding,
    metadata = excluded.metadata,
    updated_at = excluded.updated_at
RETURNING name,
    entity_type,
    embedding,
    metadata,
    created_at,
    updated_at
`

type CreateEntityParams struct {
	Name       string      `json:"name"`
	EntityType string      `json:"entity_type"`
	Embedding  interface{} `json:"embedding"`
	Metadata   string      `json:"metadata"`
	CreatedAt  int64       `json:"created_at"`
	UpdatedAt  int64       `json:"updated_at"`
}

// Create a new entity with upsert semantics
func (q *Queries) CreateEntity(ctx context.Context, arg CreateEntityParams) (Entity, error) {
	row := q.queryRow(ctx, q.createEntityStmt, createEntity,
		arg.Name,
		arg.EntityType,
		arg.Embedding,
		arg.Metadata,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Entity
	err := row.Scan(
		&i.Name,
		&i.EntityType,
		&i.Embedding,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteEntity = `-- name: DeleteEntity :exec
DELETE FROM entities
WHERE name = ?
`

// Delete entity by name
func (q *Queries) DeleteEntity(ctx context.Context, name string) error {
	_, err := q.exec(ctx, q.deleteEntityStmt, deleteEntity, name)
	return err
}

const getEntitiesByType = `-- name: GetEntitiesByType :many
SELECT name,
    entity_type,
    embedding,
    metadata,
    created_at,
    updated_at
FROM entities
WHERE entity_type = ?
ORDER BY name
`

// Get all entities of a specific type
func (q *Queries) GetEntitiesByType(ctx context.Context, entityType string) ([]Entity, error) {
	rows, err := q.query(ctx, q.getEntitiesByTypeStmt, getEntitiesByType, entityType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Entity{}
	for rows.Next() {
		var i Entity
		if err := rows.Scan(
			&i.Name,
			&i.EntityType,
			&i.Embedding,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEntitiesWithStats = `-- name: GetEntitiesWithStats :many
WITH entity_stats AS (
    SELECT e.name,
        e.entity_type,
        e.embedding,
        e.metadata,
        e.created_at,
        e.updated_at,
        COUNT(DISTINCT o.id) as observation_count,
        COUNT(
            DISTINCT CASE
                WHEN r.source = e.name THEN r.id
            END
        ) as outgoing_relation_count,
        COUNT(
            DISTINCT CASE
                WHEN r.target = e.name THEN r.id
            END
        ) as incoming_relation_count
    FROM entities e
        LEFT JOIN observations o ON e.name = o.entity_name
        LEFT JOIN relations r ON e.name = r.source
        OR e.name = r.target
    GROUP BY e.name,
        e.entity_type,
        e.embedding,
        e.metadata,
        e.created_at,
        e.updated_at
)
SELECT name, entity_type, embedding, metadata, created_at, updated_at, observation_count, outgoing_relation_count, incoming_relation_count
FROM entity_stats
ORDER BY observation_count DESC,
    created_at DESC
LIMIT ? OFFSET ?
`

type GetEntitiesWithStatsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

type GetEntitiesWithStatsRow struct {
	Name                  string      `json:"name"`
	EntityType            string      `json:"entity_type"`
	Embedding             interface{} `json:"embedding"`
	Metadata              string      `json:"metadata"`
	CreatedAt             int64       `json:"created_at"`
	UpdatedAt             int64       `json:"updated_at"`
	ObservationCount      int64       `json:"observation_count"`
	OutgoingRelationCount int64       `json:"outgoing_relation_count"`
	IncomingRelationCount int64       `json:"incoming_relation_count"`
}

// Get entities with observation counts and relation counts using window functions
func (q *Queries) GetEntitiesWithStats(ctx context.Context, arg GetEntitiesWithStatsParams) ([]GetEntitiesWithStatsRow, error) {
	rows, err := q.query(ctx, q.getEntitiesWithStatsStmt, getEntitiesWithStats, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEntitiesWithStatsRow{}
	for rows.Next() {
		var i GetEntitiesWithStatsRow
		if err := rows.Scan(
			&i.Name,
			&i.EntityType,
			&i.Embedding,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ObservationCount,
			&i.OutgoingRelationCount,
			&i.IncomingRelationCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEntity = `-- name: GetEntity :one
SELECT name,
    entity_type,
    embedding,
    metadata,
    created_at,
    updated_at
FROM entities
WHERE name = ?
`

// Get entity by name
func (q *Queries) GetEntity(ctx context.Context, name string) (Entity, error) {
	row := q.queryRow(ctx, q.getEntityStmt, getEntity, name)
	var i Entity
	err := row.Scan(
		&i.Name,
		&i.EntityType,
		&i.Embedding,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEntityWithObservations = `-- name: GetEntityWithObservations :one
WITH entity_data AS (
    SELECT name,
        entity_type,
        embedding,
        metadata,
        created_at,
        updated_at
    FROM entities
    WHERE name = ?
),
observation_data AS (
    SELECT entity_name,
        content,
        embedding,
        created_at
    FROM observations
    WHERE entity_name = ?
    ORDER BY created_at DESC
    LIMIT ?
)
SELECT e.name,
    e.entity_type,
    e.embedding,
    e.metadata,
    e.created_at,
    e.updated_at,
    GROUP_CONCAT(o.content, ' | ') as observations_content,
    COUNT(o.entity_name) as observation_count
FROM entity_data e
    LEFT JOIN observation_data o ON e.name = o.entity_name
GROUP BY e.name,
    e.entity_type,
    e.embedding,
    e.metadata,
    e.created_at,
    e.updated_at
`

type GetEntityWithObservationsParams struct {
	Name       string `json:"name"`
	EntityName string `json:"entity_name"`
	Limit      int64  `json:"limit"`
}

type GetEntityWithObservationsRow struct {
	Name                string      `json:"name"`
	EntityType          string      `json:"entity_type"`
	Embedding           interface{} `json:"embedding"`
	Metadata            string      `json:"metadata"`
	CreatedAt           int64       `json:"created_at"`
	UpdatedAt           int64       `json:"updated_at"`
	ObservationsContent string      `json:"observations_content"`
	ObservationCount    int64       `json:"observation_count"`
}

// Get entity with its observations using CTE
func (q *Queries) GetEntityWithObservations(ctx context.Context, arg GetEntityWithObservationsParams) (GetEntityWithObservationsRow, error) {
	row := q.queryRow(ctx, q.getEntityWithObservationsStmt, getEntityWithObservations, arg.Name, arg.EntityName, arg.Limit)
	var i GetEntityWithObservationsRow
	err := row.Scan(
		&i.Name,
		&i.EntityType,
		&i.Embedding,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ObservationsContent,
		&i.ObservationCount,
	)
	return i, err
}

const listEntities = `-- name: ListEntities :many
SELECT name,
    entity_type,
    embedding,
    metadata,
    created_at,
    updated_at
FROM entities
WHERE (
        ? = ''
        OR entity_type = ?
    )
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListEntitiesParams struct {
	Column1    interface{} `json:"column_1"`
	EntityType string      `json:"entity_type"`
	Limit      int64       `json:"limit"`
	Offset     int64       `json:"offset"`
}

// List entities with pagination and filtering
func (q *Queries) ListEntities(ctx context.Context, arg ListEntitiesParams) ([]Entity, error) {
	rows, err := q.query(ctx, q.listEntitiesStmt, listEntities,
		arg.Column1,
		arg.EntityType,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Entity{}
	for rows.Next() {
		var i Entity
		if err := rows.Scan(
			&i.Name,
			&i.EntityType,
			&i.Embedding,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchEntities = `-- name: SearchEntities :many
SELECT name,
    entity_type,
    embedding,
    metadata,
    created_at,
    updated_at
FROM entities
WHERE name LIKE '%' || ? || '%'
    OR entity_type LIKE '%' || ? || '%'
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type SearchEntitiesParams struct {
	Column1 sql.NullString `json:"column_1"`
	Column2 sql.NullString `json:"column_2"`
	Limit   int64          `json:"limit"`
	Offset  int64          `json:"offset"`
}

// Basic text search in entity names and types
func (q *Queries) SearchEntities(ctx context.Context, arg SearchEntitiesParams) ([]Entity, error) {
	rows, err := q.query(ctx, q.searchEntitiesStmt, searchEntities,
		arg.Column1,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Entity{}
	for rows.Next() {
		var i Entity
		if err := rows.Scan(
			&i.Name,
			&i.EntityType,
			&i.Embedding,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEntity = `-- name: UpdateEntity :one
UPDATE entities
SET entity_type = ?,
    embedding = ?,
    metadata = ?,
    updated_at = ?
WHERE name = ?
RETURNING name,
    entity_type,
    embedding,
    metadata,
    created_at,
    updated_at
`

type UpdateEntityParams struct {
	EntityType string      `json:"entity_type"`
	Embedding  interface{} `json:"embedding"`
	Metadata   string      `json:"metadata"`
	UpdatedAt  int64       `json:"updated_at"`
	Name       string      `json:"name"`
}

// Update entity with optimistic locking
func (q *Queries) UpdateEntity(ctx context.Context, arg UpdateEntityParams) (Entity, error) {
	row := q.queryRow(ctx, q.updateEntityStmt, updateEntity,
		arg.EntityType,
		arg.Embedding,
		arg.Metadata,
		arg.UpdatedAt,
		arg.Name,
	)
	var i Entity
	err := row.Scan(
		&i.Name,
		&i.EntityType,
		&i.Embedding,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
