// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: graph_edges.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const countGraphGraphEdges = `-- name: CountGraphGraphEdges :one
SELECT COUNT(*) FROM graph_edges
`

func (q *Queries) CountGraphGraphEdges(ctx context.Context) (int64, error) {
	row := q.queryRow(ctx, q.countGraphGraphEdgesStmt, countGraphGraphEdges)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countGraphGraphEdgesByRelation = `-- name: CountGraphGraphEdgesByRelation :one
SELECT COUNT(*) FROM graph_edges WHERE rel = ?
`

func (q *Queries) CountGraphGraphEdgesByRelation(ctx context.Context, rel string) (int64, error) {
	row := q.queryRow(ctx, q.countGraphGraphEdgesByRelationStmt, countGraphGraphEdgesByRelation, rel)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countGraphGraphEdgesBySource = `-- name: CountGraphGraphEdgesBySource :one
SELECT COUNT(*) FROM graph_edges WHERE src_id = ?
`

func (q *Queries) CountGraphGraphEdgesBySource(ctx context.Context, srcID string) (int64, error) {
	row := q.queryRow(ctx, q.countGraphGraphEdgesBySourceStmt, countGraphGraphEdgesBySource, srcID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countGraphGraphEdgesByTarget = `-- name: CountGraphGraphEdgesByTarget :one
SELECT COUNT(*) FROM graph_edges WHERE dst_id = ?
`

func (q *Queries) CountGraphGraphEdgesByTarget(ctx context.Context, dstID string) (int64, error) {
	row := q.queryRow(ctx, q.countGraphGraphEdgesByTargetStmt, countGraphGraphEdgesByTarget, dstID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createGraphGraphEdge = `-- name: CreateGraphGraphEdge :one
INSERT INTO graph_edges (id, src_id, dst_id, rel, attrs_json, valid_from, valid_to, ingested_at, invalidated_at, provenance_json)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT (id) DO UPDATE SET
    rel = EXCLUDED.rel,
    attrs_json = EXCLUDED.attrs_json,
    valid_to = EXCLUDED.valid_to,
    invalidated_at = EXCLUDED.invalidated_at,
    provenance_json = EXCLUDED.provenance_json
RETURNING id, src_id, dst_id, rel, attrs_json, valid_from, valid_to, ingested_at, invalidated_at, provenance_json
`

type CreateGraphGraphEdgeParams struct {
	ID             string       `json:"id"`
	SrcID          string       `json:"src_id"`
	DstID          string       `json:"dst_id"`
	Rel            string       `json:"rel"`
	AttrsJson      string       `json:"attrs_json"`
	ValidFrom      time.Time    `json:"valid_from"`
	ValidTo        sql.NullTime `json:"valid_to"`
	IngestedAt     time.Time    `json:"ingested_at"`
	InvalidatedAt  sql.NullTime `json:"invalidated_at"`
	ProvenanceJson string       `json:"provenance_json"`
}

func (q *Queries) CreateGraphGraphEdge(ctx context.Context, arg CreateGraphGraphEdgeParams) (GraphEdge, error) {
	row := q.queryRow(ctx, q.createGraphGraphEdgeStmt, createGraphGraphEdge,
		arg.ID,
		arg.SrcID,
		arg.DstID,
		arg.Rel,
		arg.AttrsJson,
		arg.ValidFrom,
		arg.ValidTo,
		arg.IngestedAt,
		arg.InvalidatedAt,
		arg.ProvenanceJson,
	)
	var i GraphEdge
	err := row.Scan(
		&i.ID,
		&i.SrcID,
		&i.DstID,
		&i.Rel,
		&i.AttrsJson,
		&i.ValidFrom,
		&i.ValidTo,
		&i.IngestedAt,
		&i.InvalidatedAt,
		&i.ProvenanceJson,
	)
	return i, err
}

const deleteGraphEdge = `-- name: DeleteGraphEdge :exec
DELETE FROM graph_edges WHERE id = ?
`

func (q *Queries) DeleteGraphEdge(ctx context.Context, id string) error {
	_, err := q.exec(ctx, q.deleteGraphEdgeStmt, deleteGraphEdge, id)
	return err
}

const getCurrentGraphGraphEdges = `-- name: GetCurrentGraphGraphEdges :many
SELECT id, src_id, dst_id, rel, attrs_json, valid_from, valid_to, ingested_at, invalidated_at, provenance_json
FROM graph_edges_current
ORDER BY ingested_at DESC
LIMIT ? OFFSET ?
`

type GetCurrentGraphGraphEdgesParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) GetCurrentGraphGraphEdges(ctx context.Context, arg GetCurrentGraphGraphEdgesParams) ([]GraphEdgesCurrent, error) {
	rows, err := q.query(ctx, q.getCurrentGraphGraphEdgesStmt, getCurrentGraphGraphEdges, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GraphEdgesCurrent{}
	for rows.Next() {
		var i GraphEdgesCurrent
		if err := rows.Scan(
			&i.ID,
			&i.SrcID,
			&i.DstID,
			&i.Rel,
			&i.AttrsJson,
			&i.ValidFrom,
			&i.ValidTo,
			&i.IngestedAt,
			&i.InvalidatedAt,
			&i.ProvenanceJson,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEntityNeighbors = `-- name: GetEntityNeighbors :many
SELECT DISTINCT e.id, e.kind, e.name, e.summary, e.attrs_json, e.created_at, e.updated_at
FROM graph_entities e
JOIN graph_edges ed ON (ed.src_id = e.id OR ed.dst_id = e.id)
WHERE ed.src_id = ? OR ed.dst_id = ?
  AND ed.valid_to IS NULL AND ed.invalidated_at IS NULL
ORDER BY e.created_at DESC
LIMIT ? OFFSET ?
`

type GetEntityNeighborsParams struct {
	SrcID  string `json:"src_id"`
	DstID  string `json:"dst_id"`
	Limit  int64  `json:"limit"`
	Offset int64  `json:"offset"`
}

func (q *Queries) GetEntityNeighbors(ctx context.Context, arg GetEntityNeighborsParams) ([]GraphEntity, error) {
	rows, err := q.query(ctx, q.getEntityNeighborsStmt, getEntityNeighbors,
		arg.SrcID,
		arg.DstID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GraphEntity{}
	for rows.Next() {
		var i GraphEntity
		if err := rows.Scan(
			&i.ID,
			&i.Kind,
			&i.Name,
			&i.Summary,
			&i.AttrsJson,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGraphEdgeAttrs = `-- name: GetGraphEdgeAttrs :one
SELECT attrs_json FROM graph_edges WHERE id = ?
`

func (q *Queries) GetGraphEdgeAttrs(ctx context.Context, id string) (string, error) {
	row := q.queryRow(ctx, q.getGraphEdgeAttrsStmt, getGraphEdgeAttrs, id)
	var attrs_json string
	err := row.Scan(&attrs_json)
	return attrs_json, err
}

const getGraphEdgeProvenance = `-- name: GetGraphEdgeProvenance :one
SELECT provenance_json FROM graph_edges WHERE graph_edges.id = ?
`

func (q *Queries) GetGraphEdgeProvenance(ctx context.Context, id string) (string, error) {
	row := q.queryRow(ctx, q.getGraphEdgeProvenanceStmt, getGraphEdgeProvenance, id)
	var provenance_json string
	err := row.Scan(&provenance_json)
	return provenance_json, err
}

const getGraphGraphEdge = `-- name: GetGraphGraphEdge :one

SELECT id, src_id, dst_id, rel, attrs_json, valid_from, valid_to, ingested_at, invalidated_at, provenance_json
FROM graph_edges
WHERE id = ?
`

// SQLC queries for graph_edges table
// These queries will be generated into Go code for type-safe database operations
func (q *Queries) GetGraphGraphEdge(ctx context.Context, id string) (GraphEdge, error) {
	row := q.queryRow(ctx, q.getGraphGraphEdgeStmt, getGraphGraphEdge, id)
	var i GraphEdge
	err := row.Scan(
		&i.ID,
		&i.SrcID,
		&i.DstID,
		&i.Rel,
		&i.AttrsJson,
		&i.ValidFrom,
		&i.ValidTo,
		&i.IngestedAt,
		&i.InvalidatedAt,
		&i.ProvenanceJson,
	)
	return i, err
}

const getGraphGraphEdgesAsOf = `-- name: GetGraphGraphEdgesAsOf :many
SELECT graph_edges.id, graph_edges.src_id, graph_edges.dst_id, graph_edges.rel, graph_edges.attrs_json, graph_edges.valid_from, graph_edges.valid_to, graph_edges.ingested_at, graph_edges.invalidated_at, graph_edges.provenance_json
FROM graph_edges
WHERE valid_from <= ? AND (valid_to IS NULL OR valid_to > ?) AND (invalidated_at IS NULL OR invalidated_at > ?)
ORDER BY ingested_at DESC
LIMIT ? OFFSET ?
`

type GetGraphGraphEdgesAsOfParams struct {
	ValidFrom     time.Time    `json:"valid_from"`
	ValidTo       sql.NullTime `json:"valid_to"`
	InvalidatedAt sql.NullTime `json:"invalidated_at"`
	Limit         int64        `json:"limit"`
	Offset        int64        `json:"offset"`
}

func (q *Queries) GetGraphGraphEdgesAsOf(ctx context.Context, arg GetGraphGraphEdgesAsOfParams) ([]GraphEdge, error) {
	rows, err := q.query(ctx, q.getGraphGraphEdgesAsOfStmt, getGraphGraphEdgesAsOf,
		arg.ValidFrom,
		arg.ValidTo,
		arg.InvalidatedAt,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GraphEdge{}
	for rows.Next() {
		var i GraphEdge
		if err := rows.Scan(
			&i.ID,
			&i.SrcID,
			&i.DstID,
			&i.Rel,
			&i.AttrsJson,
			&i.ValidFrom,
			&i.ValidTo,
			&i.IngestedAt,
			&i.InvalidatedAt,
			&i.ProvenanceJson,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGraphGraphEdgesBetweenEntities = `-- name: GetGraphGraphEdgesBetweenEntities :many
SELECT id, src_id, dst_id, rel, attrs_json, valid_from, valid_to, ingested_at, invalidated_at, provenance_json
FROM graph_edges
WHERE (src_id = ? AND dst_id = ?) OR (src_id = ? AND dst_id = ?)
ORDER BY ingested_at DESC
LIMIT ? OFFSET ?
`

type GetGraphGraphEdgesBetweenEntitiesParams struct {
	SrcID   string `json:"src_id"`
	DstID   string `json:"dst_id"`
	SrcID_2 string `json:"src_id_2"`
	DstID_2 string `json:"dst_id_2"`
	Limit   int64  `json:"limit"`
	Offset  int64  `json:"offset"`
}

func (q *Queries) GetGraphGraphEdgesBetweenEntities(ctx context.Context, arg GetGraphGraphEdgesBetweenEntitiesParams) ([]GraphEdge, error) {
	rows, err := q.query(ctx, q.getGraphGraphEdgesBetweenEntitiesStmt, getGraphGraphEdgesBetweenEntities,
		arg.SrcID,
		arg.DstID,
		arg.SrcID_2,
		arg.DstID_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GraphEdge{}
	for rows.Next() {
		var i GraphEdge
		if err := rows.Scan(
			&i.ID,
			&i.SrcID,
			&i.DstID,
			&i.Rel,
			&i.AttrsJson,
			&i.ValidFrom,
			&i.ValidTo,
			&i.IngestedAt,
			&i.InvalidatedAt,
			&i.ProvenanceJson,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGraphGraphEdgesByRelation = `-- name: GetGraphGraphEdgesByRelation :many
SELECT id, src_id, dst_id, rel, attrs_json, valid_from, valid_to, ingested_at, invalidated_at, provenance_json
FROM graph_edges
WHERE rel = ?
ORDER BY ingested_at DESC
LIMIT ? OFFSET ?
`

type GetGraphGraphEdgesByRelationParams struct {
	Rel    string `json:"rel"`
	Limit  int64  `json:"limit"`
	Offset int64  `json:"offset"`
}

func (q *Queries) GetGraphGraphEdgesByRelation(ctx context.Context, arg GetGraphGraphEdgesByRelationParams) ([]GraphEdge, error) {
	rows, err := q.query(ctx, q.getGraphGraphEdgesByRelationStmt, getGraphGraphEdgesByRelation, arg.Rel, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GraphEdge{}
	for rows.Next() {
		var i GraphEdge
		if err := rows.Scan(
			&i.ID,
			&i.SrcID,
			&i.DstID,
			&i.Rel,
			&i.AttrsJson,
			&i.ValidFrom,
			&i.ValidTo,
			&i.IngestedAt,
			&i.InvalidatedAt,
			&i.ProvenanceJson,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGraphGraphEdgesBySource = `-- name: GetGraphGraphEdgesBySource :many
SELECT id, src_id, dst_id, rel, attrs_json, valid_from, valid_to, ingested_at, invalidated_at, provenance_json
FROM graph_edges
WHERE src_id = ?
ORDER BY ingested_at DESC
LIMIT ? OFFSET ?
`

type GetGraphGraphEdgesBySourceParams struct {
	SrcID  string `json:"src_id"`
	Limit  int64  `json:"limit"`
	Offset int64  `json:"offset"`
}

func (q *Queries) GetGraphGraphEdgesBySource(ctx context.Context, arg GetGraphGraphEdgesBySourceParams) ([]GraphEdge, error) {
	rows, err := q.query(ctx, q.getGraphGraphEdgesBySourceStmt, getGraphGraphEdgesBySource, arg.SrcID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GraphEdge{}
	for rows.Next() {
		var i GraphEdge
		if err := rows.Scan(
			&i.ID,
			&i.SrcID,
			&i.DstID,
			&i.Rel,
			&i.AttrsJson,
			&i.ValidFrom,
			&i.ValidTo,
			&i.IngestedAt,
			&i.InvalidatedAt,
			&i.ProvenanceJson,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGraphGraphEdgesByTarget = `-- name: GetGraphGraphEdgesByTarget :many
SELECT id, src_id, dst_id, rel, attrs_json, valid_from, valid_to, ingested_at, invalidated_at, provenance_json
FROM graph_edges
WHERE dst_id = ?
ORDER BY ingested_at DESC
LIMIT ? OFFSET ?
`

type GetGraphGraphEdgesByTargetParams struct {
	DstID  string `json:"dst_id"`
	Limit  int64  `json:"limit"`
	Offset int64  `json:"offset"`
}

func (q *Queries) GetGraphGraphEdgesByTarget(ctx context.Context, arg GetGraphGraphEdgesByTargetParams) ([]GraphEdge, error) {
	rows, err := q.query(ctx, q.getGraphGraphEdgesByTargetStmt, getGraphGraphEdgesByTarget, arg.DstID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GraphEdge{}
	for rows.Next() {
		var i GraphEdge
		if err := rows.Scan(
			&i.ID,
			&i.SrcID,
			&i.DstID,
			&i.Rel,
			&i.AttrsJson,
			&i.ValidFrom,
			&i.ValidTo,
			&i.IngestedAt,
			&i.InvalidatedAt,
			&i.ProvenanceJson,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGraphGraphEdgesByTimeRange = `-- name: GetGraphGraphEdgesByTimeRange :many
SELECT id, src_id, dst_id, rel, attrs_json, valid_from, valid_to, ingested_at, invalidated_at, provenance_json
FROM graph_edges
WHERE ingested_at >= ? AND ingested_at <= ?
ORDER BY ingested_at DESC
LIMIT ? OFFSET ?
`

type GetGraphGraphEdgesByTimeRangeParams struct {
	IngestedAt   time.Time `json:"ingested_at"`
	IngestedAt_2 time.Time `json:"ingested_at_2"`
	Limit        int64     `json:"limit"`
	Offset       int64     `json:"offset"`
}

func (q *Queries) GetGraphGraphEdgesByTimeRange(ctx context.Context, arg GetGraphGraphEdgesByTimeRangeParams) ([]GraphEdge, error) {
	rows, err := q.query(ctx, q.getGraphGraphEdgesByTimeRangeStmt, getGraphGraphEdgesByTimeRange,
		arg.IngestedAt,
		arg.IngestedAt_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GraphEdge{}
	for rows.Next() {
		var i GraphEdge
		if err := rows.Scan(
			&i.ID,
			&i.SrcID,
			&i.DstID,
			&i.Rel,
			&i.AttrsJson,
			&i.ValidFrom,
			&i.ValidTo,
			&i.IngestedAt,
			&i.InvalidatedAt,
			&i.ProvenanceJson,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGraphGraphEdgesWithValidity = `-- name: GetGraphGraphEdgesWithValidity :many
SELECT id, src_id, dst_id, rel, attrs_json, valid_from, valid_to, ingested_at, invalidated_at, provenance_json
FROM graph_edges
WHERE valid_from >= ? AND (valid_to IS NULL OR valid_to <= ?)
ORDER BY valid_from DESC
LIMIT ? OFFSET ?
`

type GetGraphGraphEdgesWithValidityParams struct {
	ValidFrom time.Time    `json:"valid_from"`
	ValidTo   sql.NullTime `json:"valid_to"`
	Limit     int64        `json:"limit"`
	Offset    int64        `json:"offset"`
}

func (q *Queries) GetGraphGraphEdgesWithValidity(ctx context.Context, arg GetGraphGraphEdgesWithValidityParams) ([]GraphEdge, error) {
	rows, err := q.query(ctx, q.getGraphGraphEdgesWithValidityStmt, getGraphGraphEdgesWithValidity,
		arg.ValidFrom,
		arg.ValidTo,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GraphEdge{}
	for rows.Next() {
		var i GraphEdge
		if err := rows.Scan(
			&i.ID,
			&i.SrcID,
			&i.DstID,
			&i.Rel,
			&i.AttrsJson,
			&i.ValidFrom,
			&i.ValidTo,
			&i.IngestedAt,
			&i.InvalidatedAt,
			&i.ProvenanceJson,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvalidatedGraphGraphEdges = `-- name: GetInvalidatedGraphGraphEdges :many
SELECT id, src_id, dst_id, rel, attrs_json, valid_from, valid_to, ingested_at, invalidated_at, provenance_json
FROM graph_edges
WHERE invalidated_at IS NOT NULL
ORDER BY invalidated_at DESC
LIMIT ? OFFSET ?
`

type GetInvalidatedGraphGraphEdgesParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) GetInvalidatedGraphGraphEdges(ctx context.Context, arg GetInvalidatedGraphGraphEdgesParams) ([]GraphEdge, error) {
	rows, err := q.query(ctx, q.getInvalidatedGraphGraphEdgesStmt, getInvalidatedGraphGraphEdges, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GraphEdge{}
	for rows.Next() {
		var i GraphEdge
		if err := rows.Scan(
			&i.ID,
			&i.SrcID,
			&i.DstID,
			&i.Rel,
			&i.AttrsJson,
			&i.ValidFrom,
			&i.ValidTo,
			&i.IngestedAt,
			&i.InvalidatedAt,
			&i.ProvenanceJson,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const invalidateGraphEdge = `-- name: InvalidateGraphEdge :exec
UPDATE graph_edges
SET invalidated_at = CURRENT_TIMESTAMP, valid_to = CURRENT_TIMESTAMP
WHERE id = ? AND invalidated_at IS NULL
`

func (q *Queries) InvalidateGraphEdge(ctx context.Context, id string) error {
	_, err := q.exec(ctx, q.invalidateGraphEdgeStmt, invalidateGraphEdge, id)
	return err
}

const listGraphGraphGraphEdges = `-- name: ListGraphGraphGraphEdges :many
SELECT id, src_id, dst_id, rel, attrs_json, valid_from, valid_to, ingested_at, invalidated_at, provenance_json
FROM graph_edges
ORDER BY ingested_at DESC
LIMIT ? OFFSET ?
`

type ListGraphGraphGraphEdgesParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListGraphGraphGraphEdges(ctx context.Context, arg ListGraphGraphGraphEdgesParams) ([]GraphEdge, error) {
	rows, err := q.query(ctx, q.listGraphGraphGraphEdgesStmt, listGraphGraphGraphEdges, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GraphEdge{}
	for rows.Next() {
		var i GraphEdge
		if err := rows.Scan(
			&i.ID,
			&i.SrcID,
			&i.DstID,
			&i.Rel,
			&i.AttrsJson,
			&i.ValidFrom,
			&i.ValidTo,
			&i.IngestedAt,
			&i.InvalidatedAt,
			&i.ProvenanceJson,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateGraphEdge = `-- name: UpdateGraphEdge :one
UPDATE graph_edges
SET rel = ?, attrs_json = ?, valid_to = ?, invalidated_at = ?, provenance_json = ?
WHERE id = ?
RETURNING id, src_id, dst_id, rel, attrs_json, valid_from, valid_to, ingested_at, invalidated_at, provenance_json
`

type UpdateGraphEdgeParams struct {
	Rel            string       `json:"rel"`
	AttrsJson      string       `json:"attrs_json"`
	ValidTo        sql.NullTime `json:"valid_to"`
	InvalidatedAt  sql.NullTime `json:"invalidated_at"`
	ProvenanceJson string       `json:"provenance_json"`
	ID             string       `json:"id"`
}

func (q *Queries) UpdateGraphEdge(ctx context.Context, arg UpdateGraphEdgeParams) (GraphEdge, error) {
	row := q.queryRow(ctx, q.updateGraphEdgeStmt, updateGraphEdge,
		arg.Rel,
		arg.AttrsJson,
		arg.ValidTo,
		arg.InvalidatedAt,
		arg.ProvenanceJson,
		arg.ID,
	)
	var i GraphEdge
	err := row.Scan(
		&i.ID,
		&i.SrcID,
		&i.DstID,
		&i.Rel,
		&i.AttrsJson,
		&i.ValidFrom,
		&i.ValidTo,
		&i.IngestedAt,
		&i.InvalidatedAt,
		&i.ProvenanceJson,
	)
	return i, err
}

const updateGraphEdgeAttrs = `-- name: UpdateGraphEdgeAttrs :exec
UPDATE graph_edges
SET attrs_json = ?
WHERE id = ?
`

type UpdateGraphEdgeAttrsParams struct {
	AttrsJson string `json:"attrs_json"`
	ID        string `json:"id"`
}

func (q *Queries) UpdateGraphEdgeAttrs(ctx context.Context, arg UpdateGraphEdgeAttrsParams) error {
	_, err := q.exec(ctx, q.updateGraphEdgeAttrsStmt, updateGraphEdgeAttrs, arg.AttrsJson, arg.ID)
	return err
}

const updateGraphEdgeProvenance = `-- name: UpdateGraphEdgeProvenance :exec
UPDATE graph_edges
SET provenance_json = ?
WHERE id = ?
`

type UpdateGraphEdgeProvenanceParams struct {
	ProvenanceJson string `json:"provenance_json"`
	ID             string `json:"id"`
}

func (q *Queries) UpdateGraphEdgeProvenance(ctx context.Context, arg UpdateGraphEdgeProvenanceParams) error {
	_, err := q.exec(ctx, q.updateGraphEdgeProvenanceStmt, updateGraphEdgeProvenance, arg.ProvenanceJson, arg.ID)
	return err
}
